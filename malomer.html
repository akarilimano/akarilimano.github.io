<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" class="dj_webkit dj_chrome dj_contentbox"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!--meta http-equiv="Cache-Control" content="no-cache"-->

<script type="text/javascript" src="https://code.jquery.com/jquery-2.2.4.min.js"></script>

<title>
    Malomer
</title>

<style type="text/css">
.strike {
    text-decoration: line-through;
}

canvas {
	cursor: none;
}
</style>

<script>
$(function() {
	var letsdraw ;
	let ml = {
		x: 50,
		y: 500,
		w: 200,
		h: 50,
		smooth: 4,
		phSize: 15,
	};
	let angle = {x: 600, y: 150, alpha: 10, beta: 65, radius: 100};  // 0 <= Alpha <= Beta <= 360
	let minimumAngle = 20;
	let angleChange = 10;
	var polarPhi = 0;
	var angleCleared = false;
	var isAngleBroken = false;
	var isOnAngle = false;
	var isPaused = false;
	var score = {
		value: 0,
		healingAmount: 10,   // increase score when angle is temporarily healed
		healedAmount: 100,   // increase score when angle is healed and removed
		breakingAmount: 2,  // reduce score when angle is getting broken
		brokenAmount: 10,  // reduce score when angle is too small
		healedNumber: 0,
	};
	score.increaseBy = (value) => score.value += value;
	score.reduceBy = (value) => score.value = Math.max(0, score.value-value);  // Score value cannot be less than 0

	var current = {x: 400, y: 200};

	var theCanvas = document.getElementById('paint');
	var ctx = theCanvas.getContext('2d');
	theCanvas.width = 800;
	theCanvas.height = 600;

	var canvasOffset = $('#paint').offset();

	let mainColor = '#7592b2';
	let backColor = '#345983';
	var eyeColor = '#00000c';
	ctx.lineWidth = 2;
	ctx.font = '48px serif';

	let drawMalomer = function(x, y) {
		let timeSeed = Date.now()/400;
		let end = current;
		// body
		ctx.beginPath();
		ctx.strokeStyle = eyeColor;
		ctx.fillStyle = mainColor;
		// ctx.fillRect(ml.x, ml.y, ml.w, ml.h);
		// ctx.strokeRect(ml.x, ml.y, ml.w, ml.h);
		ctx.moveTo(ml.x, ml.y);
		ctx.arcTo(ml.x, ml.y+ml.h, ml.x+ml.w, ml.y+ml.h, ml.smooth);
		ctx.arcTo(ml.x+ml.w, ml.y+ml.h, ml.x+ml.w, ml.y, ml.smooth);
		ctx.arcTo(ml.x+ml.w, ml.y, ml.x, ml.y, ml.smooth);
		ctx.arcTo(ml.x, ml.y, ml.x, ml.y+ml.h, ml.smooth);
		ctx.fill();
		ctx.stroke();
		// eyes
		ctx.fillStyle = eyeColor;
		ctx.fillRect(ml.x+20-Math.sin((x + timeSeed)/300)*2+end.x/40, ml.y+10+end.y/40, 2, 2);
		ctx.fillRect(ml.x+ml.w-50-Math.sin((x + timeSeed)/300)*2+end.x/20, ml.y+10+end.y/40, 2, 2);
		// mouth
		let mouth = {
			x: 45,
			w: 100
		};
		let startX = ml.x+mouth.x-Math.sin((x+y)/300)*2+end.x/60;
		let startY = ml.y+30+end.y/60;
		let endX = startX+ml.x-mouth.x+mouth.w+Math.cos((x+y)/300+timeSeed)*2;
		// ctx.fillRect(startX, startY, endX, 2);
		if (angleCleared) {
			ctx.moveTo(startX, startY-2);
			ctx.arcTo(startX, startY, startX+2, startY, 2);
			ctx.arcTo(endX, startY+1, endX, startY-2, 2);
		} else {
			if (isAngleBroken) {
				ctx.moveTo(startX, startY);
				ctx.lineTo(endX, startY+2);
			} else {
				ctx.moveTo(startX, startY);
				ctx.lineTo(endX, startY-1);
			}
		}
		ctx.stroke();
		// ctx.arcTo(ml.x+mouth.x-Math.sin((x+y)/300)*2+end.x/60, ml.y+30+end.y/60, ml.x-mouth.x+mouth.w+Math.cos((x+y)/300+timeSeed)*2, 2);

		// legs
		ctx.fillStyle = mainColor;
		let legSize = {h: 15, w: 10, thick: 5};
		let legs = [
			{x: 20, h: legSize.h, w: legSize.w, thick: legSize.thick, phi: 0},
			{x: 50, h: legSize.h, w: legSize.w, thick: legSize.thick, phi: Math.PI/2},
			{x: 130, h: legSize.h, w: legSize.w, thick: legSize.thick, phi: Math.PI},
			{x: 170, h: legSize.h, w: legSize.w, thick: legSize.thick, phi: Math.PI*3/2}
		];
		legs.forEach(leg => {
			// ctx.fillRect(ml.x+leg.x, ml.y+ml.h, 2, leg.h+Math.sin((timeSeed)/2+leg.phi)*2);
			// ctx.strokeRect(ml.x+leg.x, ml.y+ml.h, 2, leg.h+Math.sin((timeSeed)/2+leg.phi)*2);
			// ctx.fillRect(ml.x+leg.x+4, ml.y+ml.h+leg.h-2+Math.sin((timeSeed)/2+leg.phi)*2, leg.w, 2);
			// ctx.strokeRect(ml.x+leg.x+4, ml.y+ml.h+leg.h-2+Math.sin((timeSeed)/2+leg.phi)*2, leg.w, 2);
			ctx.beginPath();
			ctx.moveTo(ml.x+leg.x, ml.y+ml.h);
			let length = Math.sin((timeSeed)/2+leg.phi)*2;
			let round = 3;
			// ctx.lineTo(ml.x+leg.x, ml.y+ml.h+leg.h+length-round);
			ctx.arcTo(ml.x+leg.x, ml.y+ml.h+leg.h+length, ml.x+leg.x+leg.w, ml.y+ml.h+leg.h+length, round);
			ctx.lineTo(ml.x+leg.x+leg.w, ml.y+ml.h+leg.h+length);
			ctx.arcTo(ml.x+leg.x+leg.w, ml.y+ml.h+leg.h+length - leg.thick, ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h+leg.h+length - leg.thick, round);
			ctx.arcTo(ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h+leg.h+length - leg.thick, ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h, round);
			//ctx.arcTo(ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h, ml.x+leg.x, ml.y+ml.h+leg.h+length, round);
			// ctx.lineTo(ml.x+leg.x+leg.w, ml.y+ml.h+leg.h+length - leg.thick);
			// ctx.lineTo(ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h+leg.h+length - leg.thick);
			ctx.lineTo(ml.x+leg.x+leg.w-leg.thick, ml.y+ml.h);
			//ctx.lineTo(ml.x+leg.x, ml.y+ml.h+leg.h+length);
			ctx.fill();
			ctx.stroke();
		});
		// tail
		ctx.fillStyle = mainColor;
		ctx.beginPath();

		ctx.moveTo(ml.x, ml.y);
		// ctx.lineTo(e.pageX - canvasOffset.left, e.pageY - canvasOffset.top);
		// let curv = {x: Math.abs(ml.x - end.x)/5, y: Math.abs(ml.y - end.y)/5};
		let r = Math.random();
		let curv = {x: Math.random()*2+Math.max(Math.abs(ml.x - end.x)/5, 30), y: Math.max(Math.random()*2+Math.abs(ml.y - end.y)/5, 20)};

		let cp1 = {x: ml.x-curv.x, y: ml.y-curv.y};
		let cp2 = {x: end.x-curv.x, y: end.y+curv.y};
		// let cp1 = {x: ml.y-curv.y, y: ml.x-curv.y};
		// let cp2 = {x: end.x+curv.x, y: end.y+curv.y};
		let midreal = {x: (end.x*3/5+ml.x*2/5), y: (end.y*3/5+ml.y*2/5)};
		// let mid = {x: (end.x+ml.x)/2, y: (end.y+ml.y)/2};
		let mid = {x: midreal.x+Math.max(Math.abs(ml.x - end.x)/5, 15)*Math.cos(timeSeed), y: midreal.y+Math.max(Math.abs(ml.y - end.y)/10, 10)*Math.sin(timeSeed)};

		// let mid = {
		//      x: ((midreal.x+ml.x)*0.9*Math.pow(Math.sin(timeSeed), 2)+(midreal.x+end.x)*0.9*Math.pow(Math.cos(timeSeed), 2)),

		//      y: ((midreal.y+ml.y)*0.9*Math.pow(Math.sin(timeSeed), 2)+(midreal.y+end.y)*0.9*Math.pow(Math.cos(timeSeed), 2))};

		let middif = {x: (cp1.x-cp2.x)/2, y: (cp1.y-cp2.y)/2};
		let sizeWave = 15;
		let midcp1 = {x: mid.x+Math.sin((mid.x+mid.y)/300)*sizeWave-20, y: mid.y+Math.max(middif.y, middif.y)+Math.cos((mid.x+mid.y)/300)*sizeWave};

		let midcp2 = {x: mid.x-Math.sin((mid.x+mid.y)/300)*sizeWave+20, y: mid.y-Math.max(middif.y, middif.y)-Math.cos((mid.x+mid.y)/300)*sizeWave};

		ctx.bezierCurveTo(cp1.x, cp1.y, midcp1.x, midcp1.y, mid.x, mid.y);
		ctx.bezierCurveTo(midcp2.x, midcp2.y, cp2.x, cp2.y, end.x, end.y);
		// tail end
		ctx.lineTo(end.x+10, end.y-7);
		ctx.moveTo(end.x, end.y);
		ctx.lineTo(end.x+7, end.y+3);
		ctx.stroke();
		/*
		if (isOnAngle) {
			ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
			ctx.beginPath();
			ctx.ellipse(end.x, end.y, 10, 10, 0, 0, Math.PI*2);
			// ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
			// ctx.fillStyle="#FFFF00";
			// ctx.stroke();
			ctx.fill();
		}
		*/

		// ctx.strokeRect(cp1.x, cp1.y, 1, 1);
		// ctx.strokeRect(cp2.x, cp2.y, 1, 1);
		// ctx.strokeRect(mid.x, mid.y, 1, 1);
		// ctx.strokeRect(midreal.x, midreal.y, 1, 1);
		// ctx.strokeRect(midcp1.x, midcp1.y, 1, 1);
		// ctx.strokeRect(midcp2.x, midcp2.y, 1, 1);
	};

	let drawAngle = function() {
		if (angleCleared || isPaused) {
				return;
		}
		ctx.strokeStyle = eyeColor;
		ctx.fillStyle = eyeColor;
		ctx.moveTo(angle.x, angle.y);
		ctx.lineTo(angle.x+angle.radius*Math.cos(Math.PI*angle.alpha/180), angle.y-angle.radius*Math.sin(Math.PI*angle.alpha/180));

		ctx.moveTo(angle.x, angle.y);
		ctx.lineTo(angle.x+angle.radius*Math.cos(Math.PI*angle.beta/180), angle.y-angle.radius*Math.sin(Math.PI*angle.beta/180));

		ctx.stroke();
				
		if (isOnAngle) {
			ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
			ctx.beginPath();
			ctx.ellipse(angle.x, angle.y, angle.radius/10, angle.radius/10, Math.PI*180/180, Math.PI*(180-angle.alpha)/180, Math.PI*(180-angle.beta)/180, true);
			// ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
			// ctx.fillStyle="#FFFF00";
			// ctx.stroke();
			ctx.fill();
			ctx.beginPath();
			ctx.ellipse(angle.x, angle.y, 10, 10, 0, 0, Math.PI*2);
			// ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
			// ctx.fillStyle="#FFFF00";
			// ctx.stroke();
			ctx.fill();
		}
	};

	let drawScene = function() {
		// isOnAngle = false;
		ctx.clearRect(0,0,theCanvas.width,theCanvas.height);
		// drawBack
		if (isOnAngle) {
			// ctx.fillStyle = backColor;
				
			ctx.globalAlpha = 0.5;
			ctx.fillStyle = eyeColor;
			ctx.fillRect(angle.x, angle.y, 40, 40);
			ctx.globalAlpha = 1;
		} else {
			// ctx.fillStyle = mainColor;
			;
		}
		ctx.fillStyle = mainColor;
		ctx.fillRect(0,0,theCanvas.width,theCanvas.height);
		drawMalomer(current.x, current.y);
		drawAngle();
		// draw score
		ctx.fillStyle = eyeColor;
		ctx.fillText('Score: ' + score.value, 10, 50);
		// ctx.fillText('A: ' + angle.alpha, 10, 100);
		// ctx.fillText('B: ' + angle.beta, 10, 150);
		// ctx.fillText('Phi: ' + polarPhi, 10, 250);
		
		if (isPaused) {
			ctx.fillText('PAUSED', 300, 270);
		}
	};

	let checkAngle = function() {
		if (angleCleared) {
				// console.debug("Checked, angle was already cleared.");
				return;
		}
		isOnAngle = false;
		let dx = current.x-angle.x;
		let dy = current.y-angle.y;
		let polarR = Math.sqrt(dx*dx + dy*dy);
		if (polarR <= ml.phSize) {
			// Check the mouse is 'inside' of an angle is broken, so just use a small area around
			// polarPhi = (Math.atan2(-dy, dx)*180/Math.PI + 360) % 360;
			// if ((polarPhi > angle.alpha && polarPhi < angle.beta) || (polarPhi > angle.beta && polarPhi < angle.alpha)) {

					// healAngle();
					isOnAngle = true;
					// eyeColor = 'red';
			// }
		}
		return;
	}

	let healAngle = function() {
		score.increaseBy(score.healingAmount);
		angle = {
			...angle,
			alpha: (angle.alpha - angleChange + 360) % 360,
			beta: (angle.beta + angleChange + 360) % 360
		};
		
		if (Math.abs(angle.alpha - angle.beta) % 360 <= 10) {
			angleCleared = true;
			score.healedNumber += 1;
			score.increaseBy(score.healedAmount);
			isOnAngle = false;
			setTimeout(makeNewAngle, 2000);
			// alert("You scored: " + score + " points!");
		}
	}
	
	let breakAngle = function() {
		if (angleCleared) {
			return;
		}
		if (Math.abs(angle.alpha - angle.beta) < minimumAngle + 5 && angle.alpha < angle.beta){
			// Angle is too small, lose points
			console.debug(angle.alpha, angle.beta);
			score.reduceBy(score.brokenAmount);
			isAngleBroken = true;
			return;
		}
		angle.alpha += 1;
		angle.beta -= 1;
		isAngleBroken = false;
		
		score.reduceBy(score.breakingAmount);
	}

	let makeNewAngle = function() {		
		if (isPaused) {
			// cancel new angle if it is a pause
			return;
		}

		let newX = Math.random()*(theCanvas.width - 150)+100;
		let newY = Math.random()*(theCanvas.height - 250)+100;
		let newAlpha = Math.random()*(360 - minimumAngle);  // 0-335; [a-25-1; a+25+1]
		let angleDiff = Math.random()*(360 - 2*(minimumAngle + 5)) + minimumAngle + 5;
		let newBeta = (newAlpha + angleDiff + 360) % 360;
		// let newBeta = (newAlpha + Math.random()*(newAlpha + minimumAngle + 1) - minimumAngle - 1 + 360) % 360;  // 0 + (360-0-50-1) +25 = 334;   334 + (360-334-50-1) +25 = 
		let newRadius = Math.random()*40+90;
		angle = {
			...angle,
			x: newX,
			y: newY,
			alpha: Math.min(newAlpha, newBeta),
			beta: Math.max(newAlpha, newBeta),
			radius: newRadius,
		}
		angleCleared = false;
		console.debug(angle);
	}

	setInterval(() => {
		if (!isPaused) {
			breakAngle();
		}
		checkAngle();
		drawScene();
	}, 80);

	$('#paint').mousemove(function(e) {
		current = {x: e.pageX - canvasOffset.left, y: e.pageY - canvasOffset.top};

		//drawScene();
	});

	$('#paint').click(function(e) {
		if (isPaused) {
			return;
		}
		// current = {x: e.pageX - canvasOffset.left, y: e.pageY - canvasOffset.top};
		if (isOnAngle) {
			healAngle();
		}
		// checkAngle();
		//drawScene();
	});
	
	document.body.onkeyup = function(e) {
		if (e.key == " " ||
			e.code == "Space" ||      
			e.keyCode == 32      
		) {
			isPaused = !isPaused;
			
			// To avoid pause expoiting clear the angle before the pause and make new angle after it
			angleCleared = true;
			isOnAngle = false;
			if (!isPaused) {
				setTimeout(makeNewAngle, 2000);
			}
		}
	}

});
</script>

</head>

<body>

	<canvas id="paint"></canvas>

</body></html>